# Database file layout:
* Global header
* Indices header
* Records header
* Records
* Indices
  * Index entries

All non-varint integers are big endian and unsigned. The top bit is never set.

Global header:
  - magic char[4]
  - record length u31
  - index length u31
  - top sequence u31

Indices header: (index count u31)
Index header: (term u15, count u15)
Index item: (index term string, id u31)

Record: (length varint, sequence varint, valuetype*, null char[1] == {0})
The length doesn't include itself or the trailing null byte, only the sequence
and valuetypes.
If sequence == -1, the record is scrubbed. The rest of the record space is
filled with 0x7F characters and should be ignored.

Valuetype: (type u7, data byte[])
  - type = 1 --> NULL
  - type = 2 --> FALSE
  - type = 3 --> TRUE
  - type = 4 --> string
    - string: (binary length varint, symbols char[])
  - type = 5 --> varint
    - varint: [0..01] = 0 (therefore -1 is encoded overlongly, in 2 bytes)
              [0a..bs] = (+/-s) [a..b] (6 bit)
              [1a..b] [0c..ds] = (+/-s) [a..bc..d] (13 bit)
              [1a..b] [1c..d] [0e..fs] = (+/-s) [a..bc..de..f] (20 bit)
              max len: 9 bytes, 62 bit

# WAL log layout:
* (magic char[8], rowcount u31, reserved u31)
* rows

WAL row:
* (operation type u15, sequence u15)
* data

Operation Type:
  - OperTyp = 1 --> insert
  - OperTyp = 2 --> edit
  - OperTyp = 3 --> delete

Any WAL entries will modify all the record offsets respective to their actions.
All Start offsets are relative to the record region start in the data file.

If the WAL exists, either the database file is still open by another process or
it should be replayed atop the current file because the changes weren't flushed
to the database previously due to, e.g., application crashing. WAL itself should
be persisted to the primary file as part of the application exit procedure.

For WAL with type 3, the data portion is just the deleted ID.
